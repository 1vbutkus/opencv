# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Aperm in C
#' 
#' Transform data ordering
#' 
#' Function \code{\link{aperm}} is generalization of transpose function (\code{\link{t}}) that works for arrays.
#' We need this function for communication between R array and cv:mat.
#' The order of data in cv:mat (on 2x2x2 input) goes like this: r1c1C1 r1c1C2 r1c2C1 ...
#' While the order of data in R (on same input): r1c1C1 r2c1C1 r1c2C1 ...
#' 
#' This function calls \code{\link{aperm}} function form C (it is not the most effective way, but it works).
#' 
#' Actually, we don't need this function in R, this it is loaded for debugging purposes.
#' 
#' @return An array with transformed data
#' @param RMat \code{numeric} array.
#' @param resize a flag indicating whether the vector should be resized as well as having its elements reordered (default \code{TRUE}).
#' @keywords internal
#' @export
aperm2cv <- function(RMat, resize = TRUE) {
    .Call('opencv_aperm2cv', PACKAGE = 'opencv', RMat, resize)
}

test_cv1 <- function(RMat, show = TRUE) {
    .Call('opencv_test_cv1', PACKAGE = 'opencv', RMat, show)
}

test_cv2 <- function(RMat) {
    .Call('opencv_test_cv2', PACKAGE = 'opencv', RMat)
}

#' Thinning 
#' 
#' Thinning a binary image
#' 
#' This function performs thinning procedures for binary images. Two algorithms are implemented, namely:
#' Guo-Hall and Zhang-Suen lagorithms.
#' 
#' @author The core of code was written by Nashruddin Amin and posted in http://opencv-code.com blog.
#' @return The matrix of transformed image.
#' @param RMat a \code{matrix} of image.
#' @param method \code{numeric} 0 or 1. If \code{method==0} (the default) Guo-Hall algorith is applied.  If \code{method==1} Zhang-Suen algorithm is applied.
#' @param threshold a threshold value that separates 0 and 1 (black and white). If \code{0} (the default) no threshold is applied (i.e. the values remains continuous) 
#' @export
#' @examples
#' if(require("png") & require("raster")){
#'   img <- img2grayscale(readPNG(system.file("pictures", "FatNote.png", package="opencv")))
#'   thinimg0 <- thinning(img, method=0)
#'   thinimg1 <- thinning(img, method=1)
#'   op = par(mfrow = c(3, 1), mar=c(2,2,2,1))
#'   plotImg(img, main="original")
#'   plotImg(thinimg0, main="thinning (method=0)")
#'   plotImg(thinimg1, main="thinning (method=1)")
#'   par(op)
#' }     
thinning <- function(RMat, method = 0L, threshold = 0) {
    .Call('opencv_thinningFromR', PACKAGE = 'opencv', RMat, method, threshold)
}

#' matchTemplate
#' 
#' matchTemplate function from opencv library
#' 
#' This function calls matchTemplate function form opencv library. For special details see documentation of
#' opencv. 
#' 
#' The function slides through image, compares the overlapped patches against templ using 
#' the specified method and stores the comparison results in result . 
#' Here are the formula for the available comparison methods ( I denotes image, T template, R result ).
#' The method must be number from 0 to 5.  
#' 
#' \code{method=0}(SQDIFF)
#' \deqn{ R(x, y) = \sum (T(x', y') - I(x+x', y+y'))^2  }
#' 
#' \code{method=1}(SQDIFF_NORMED)
#' \deqn{ R(x, y) = \sum (T(x', y') - I(x+x', y+y'))^2 / \sqrt{\sum (T(x', y')^2 \sum I(x+x', y+y')^2 }}  
#' 
#' \code{method=2}(CCORR)
#' \deqn{ R(x, y) = \sum T(x', y')I(x+x', y+y')  }
#' 
#' \code{method=3}(CCORR_NORMED)
#' \deqn{ R(x, y) = \sum T(x', y')I(x+x', y+y') / \sqrt{\sum (T(x', y')^2 \sum I(x+x', y+y')^2 }}
#' 
#' \code{method=4}(CCOEFF)
#' \deqn{ R(x, y) = \sum T'(x', y')I'(x+x', y+y')  }
#' 
#' \code{method=5}(CCOEFF_NORMED)
#' \deqn{ R(x, y) = \sum T'(x', y')I'(x+x', y+y') / \sqrt{\sum (T'(x', y')^2 \sum I'(x+x', y+y')^2 }}
#' 
#' where 
#' \deqn{ T' = T - mean(T)} 
#' \deqn{ I'(x,y) = I(x,y) - mean(I, by=(x', y'))}
#' 
#' @seealso GFiler2D_bf
#' 
#' @return A 2D matrix with \eqn{R} values.
#' @param image \code{numeric} array (2D ir 3D) of image data.
#' @param templ \code{numeric} array (2D ir 3D) of image data. The size of \code{templ} must be not greater then \code{image}.
#' @param method \code{integer} value form 0 to 5. See details.
#' @export
#' @examples
#' if(require("png") & require("raster")){
#'   img <- readPNG(system.file("pictures", "minesweeper.png", package="opencv"))
#'   tm <- readPNG(system.file("pictures", "minesweeper_bomb.png", package="opencv"))
#'   op = par(mfrow = c(1, 2), mar=c(2,2,2,1))
#'   plotImg(img, main="image")
#'   plotImg(tm, main="template")
#'   par(op)
#'   filter <- matchTemplate_cv(img, tm, method=1)
#'   ids <- which(filter<=0.001)
#'   length(ids)
#'   rowids <- row(filter)[ids]
#'   colids <- col(filter)[ids]
#'   op = par(mfrow = c(1, 1), mar=c(2,2,2,1))
#'   plotImg(img, main="image")
#'   points(colids, -rowids, pch=19, col=3)
#'   par(op)
#' }
matchTemplate_cv <- function(image, templ, method = 0L) {
    .Call('opencv_matchTemplate_cv', PACKAGE = 'opencv', image, templ, method)
}

#' Linear 2D filter
#' 
#' Linear 2D filter from opencv
#' 
#' This function calls filter2D function from opencv. For special details see documentation of
#' opencv. 
#' 
#' The borderType must be in \code{0:4}. It is pixel extrapolation method in area of borders. The meaning of values:
#' \itemize{
#'   \item 0 BORDER_CONSTANT 	
#'   \item 1 BORDER_REPLICATE   
#'   \item 2 BORDER_REFLECT   
#'   \item 3 BORDER_WRAP   
#'   \item 4 BORDER_DEFAULT   
#' }
#' 
#' @return An array with the same dimensiosn as \code{image}. If you don't need borders, you have to crop it your self.
#' @param image \code{numeric} vector.
#' @param kernel \code{numeric} vector.
#' @param anchor \code{numeric} vector.
#' @param delta \code{numeric} vector.
#' @param borderType \code{numeric} vector.
#' @export
#' @examples
#' if(require("png") & require("raster")){
#'   ### the meaning of borders
#'   img <- readPNG(system.file("pictures", "art.png", package="opencv"))
#'   gaus <- function(x, y, sigma=1) 1/(2*pi*sigma^2)*exp(-1/(2*sigma^2)*(x^2+y^2))
#'   fil <- outer(-30:30, -30:30, gaus, sigma=7)
#'   fil <- fil/sum(fil)
#'   plotImg(fil/max(fil), main="filter")
#'   f0 = filter2D_cv(img, kernel=fil, anchor=c(-1,-1), borderType=0)
#'   f1 = filter2D_cv(img, kernel=fil, anchor=c(-1,-1), borderType=1)
#'   f2 = filter2D_cv(img, kernel=fil, anchor=c(-1,-1), borderType=2)
#'   f3 = filter2D_cv(img, kernel=fil, anchor=c(-1,-1), borderType=3)
#'   f4 = filter2D_cv(img, kernel=fil, anchor=c(-1,-1), borderType=4)
#'   op = par(mfrow = c(3, 2), mar=c(2,2,2,1))
#'   plotImg(img, main="original")
#'   plotImg(f0, main="BORDER_CONSTANT (0)")
#'   plotImg(f1, main="BORDER_REPLICATE (1)")
#'   plotImg(f2, main="BORDER_REFLECT (2)")
#'   plotImg(f3, main="BORDER_WRAP (3)")
#'   plotImg(f4, main="BORDER_DEFAULT (4)")
#'   par(op)
#'   
#'   ### fat -> thin -> fat
#'   img <- img2grayscale(readPNG(system.file("pictures", "FatNote.png", package="opencv")))
#'   thinImg <- thinning(img)
#'   fil = matrix(c(1, 2, 1, 2, 4, 2, 1, 2, 1), 3, 3)/4
#'   plotImg(fil, main="filter")
#'   filterimg = filter2D_cv(thinImg, kernel=fil, anchor=c(-1,-1))
#'   filterimg[filterimg>1] = 1
#'   op = par(mfrow = c(3, 1), mar=c(2,2,2,1))
#'   plotImg(img, main="original")
#'   plotImg(thinImg, main="thin")
#'   plotImg(filterimg, main="back to fat")
#'   par(op)
#'} 
filter2D_cv <- function(image, kernel, anchor, delta = 0, borderType = 4L) {
    .Call('opencv_filter2D_cv', PACKAGE = 'opencv', image, kernel, anchor, delta, borderType)
}

#' General form of 2D filter
#' 
#' Cutom made 2D fiter
#' 
#' General form filter. Returns matrix \code{res} with values \code{res[i,j] = sum(K*(A[si, sj] - D)^p)}.
#' This filtering is very not efficient (it written in brute force sile). Nevertheless, it works good and it quite flexible.
#' It allows to match template using masks (see examples).
#' 
#' 
#' @seealso matchTemplate_cv
#' 
#' @return The \code{matrix}.
#' @param A big \code{matrix} that will be filtered.
#' @param D samall \code{matrix} that will be used in difference.
#' @param K samall \code{matrix} that will be used as kernel
#' @param p the power of differences.
#' @export
#' @examples
#' if(require("png") & require("raster")){
#'   img <-readPNG(system.file("pictures", "minesweeper.png", package="opencv"))
#'   tm <- readPNG(system.file("pictures", "minesweeper_bomb_transparent.png", package="opencv"))
#'   op = par(mfrow = c(1, 2), mar=c(2,2,2,1))
#'   plotImg(img, main="image")
#'   plotImg(tm, main="template")
#'   par(op)
#'   w <- tm[,,4]
#'   img2D <- img2grayscale(img)
#'   tm2D <- img2grayscale(tm)
#'   filter <- GFiler2D_bf(A=img2D, D=tm2D, K=w, p=2)
#'   ids <- which(filter<=0.001)
#'   length(ids)
#'   rowids <- row(filter)[ids]
#'   colids <- col(filter)[ids]
#'   op = par(mfrow = c(1, 1), mar=c(2,2,2,1))
#'   plotImg(img, main="image")
#'   # note that the `red` boob also matched. 
#'   points(colids, -rowids, pch=19, col=3) 
#'   par(op)
#' }
GFiler2D_bf <- function(A, D, K, p = 1) {
    .Call('opencv_GFiler2D_bf', PACKAGE = 'opencv', A, D, K, p)
}

